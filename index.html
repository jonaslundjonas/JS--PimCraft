<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PimCraft - Survival Mode</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: white;
            transform: translate(-50%, -50%);
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            line-height: 1.5;
        }

        #health-bar-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            border-radius: 10px;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #ff4444;
            border-radius: 8px;
            transition: width 0.2s;
        }

        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
            opacity: 0;
            transition: opacity 0.1s;
            pointer-events: none;
            z-index: 5;
        }
        
        #heal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0, 255, 0, 0.4) 100%);
            opacity: 0;
            transition: opacity 0.1s;
            pointer-events: none;
            z-index: 5;
        }

        #toolbar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            overflow-x: auto;
            white-space: nowrap;
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 5px;
            scrollbar-width: none; 
            -ms-overflow-style: none;
        }
        #toolbar-container::-webkit-scrollbar { 
            display: none; 
        }

        #toolbar {
            display: inline-flex;
            gap: 5px;
        }

        .slot {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255,255,255,0.3);
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 0 #000;
            transition: transform 0.1s, border-color 0.1s;
            position: relative;
            flex-shrink: 0;
        }

        .slot.active {
            border-color: yellow;
            transform: scale(1.1);
            background: rgba(255,255,255,0.2);
            z-index: 2;
        }

        .slot canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .slot-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 8px;
            z-index: 3;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: white;
            text-align: center;
            perspective: 1000px;
        }

        #instructions {
            font-size: 16px;
            cursor: pointer;
            padding: 40px;
            background: rgba(0,0,0,0.5);
            border: 4px solid white;
            position: relative;
            line-height: 2;
        }

        #instructions:hover {
            background: rgba(50,50,50,0.9);
        }
        
        #credits {
            margin-top: 20px;
            font-size: 12px;
            color: #ddd;
            text-shadow: 1px 1px 0 #000;
        }

        #gameTitle {
            font-family: 'Press Start 2P', cursive;
            font-size: 70px; 
            margin-bottom: 40px;
            display: block;
            background: linear-gradient(to bottom, #DBA514 0%, #FFEE88 25%, #D4AF37 50%, #FFEE88 75%, #CC9900 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rotateLogo 6s infinite ease-in-out;
            filter: drop-shadow(4px 4px 0px #000);
        }
        
        .menu-btn {
            background: #555;
            border: 2px solid #fff;
            color: white;
            font-family: 'Press Start 2P', cursive;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            font-size: 14px;
        }
        .menu-btn:hover {
            background: #777;
            transform: scale(1.05);
        }
        
        #menu-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        /* Hide file input */
        #file-input {
            display: none;
        }

        @keyframes rotateLogo {
            0% { transform: rotateY(-20deg); }
            50% { transform: rotateY(20deg); }
            100% { transform: rotateY(-20deg); }
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="heal-overlay"></div>

    <div id="blocker">
        <div id="instructions">
            <div id="gameTitle">PimCraft</div>
            <p>CLICK TO PLAY</p>
            <p>WASD to Move | SPACE to Jump / Ascend</p>
            <p>F to Fly | SHIFT to Descend</p>
            <p>Left Click: Mine / Attack</p>
            <p>Right Click: Place Block</p>
            <p style="color:#ff8888">HUNT BUNNIES (Attack)</p>
            <p style="color:#ffff88">CATCH HOT DOGS (Heal)</p>
            <p style="color:#00ffff">MOBS LOVE GLOWSTONE</p>
            
            <div id="menu-actions">
                <button class="menu-btn" id="newBtn">New World</button>
                <button class="menu-btn" id="saveBtn">Save World</button>
                <button class="menu-btn" id="loadBtn">Load World</button>
            </div>
        </div>
        <div id="credits">created by Jonas - 2025</div>
    </div>

    <!-- Hidden file input for loading -->
    <input type="file" id="file-input" accept=".pimcraft">

    <div id="crosshair"></div>
    
    <div id="health-bar-container">
        <div id="health-bar"></div>
    </div>
    
    <div id="ui">
        <div>FPS: <span id="fps">0</span></div>
        <div>Block: <span id="blockName">Grass</span></div>
        <div>Health: <span id="hp-val">100</span>%</div>
        <div>Bunnies: <span id="bunny-count">0</span></div>
        <div>Flying: <span id="fly-status" style="color:yellow">OFF</span></div>
    </div>

    <div id="toolbar-container">
        <div id="toolbar"></div>
    </div>

    <script>
        // --- Configuration ---
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 3; 
        const WORLD_DEPTH = 50; 
        
        const PLAYER_HEIGHT = 1.75;
        const PLAYER_RADIUS = 0.3; 
        
        // Movement Physics Tuning (Balanced Pace)
        const PLAYER_SPEED = 4.0; // Slightly faster to outrun bunnies
        const FLY_SPEED = 10.0;      
        const FLY_ASCEND_SPEED = 8.0; 
        const FRICTION = 7.0;        
        const ACCELERATION = 40.0;
        const PLAYER_JUMP = 15.0; 
        const GRAVITY = 30.0; 

        // --- Global Variables ---
        let camera, scene, renderer;
        let controls;
        let raycaster;
        let blockGroup, transparentBlockGroup, pickaxeGroup, mobGroup;
        let ambientLight, dirLight; 
        
        // World Generation Seed & Mod Store
        let seedOffset = { x: 0, z: 0 };
        const chunkMods = new Map();
        // New: Track active glowstones for mob AI
        const activeLights = new Set(); 

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let canJump = false, isFlying = false;
        
        // Action States
        let isLeftMouseDown = false;
        let isRightMouseDown = false;
        let isMining = false; 
        let miningTimer = 0;
        let actionCooldown = 0;
        const ACTION_DELAY = 0.25; 
        
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Player Stats
        let playerHealth = 100;
        let lastHitTime = 0;

        let currentBlockIndex = 0;
        const blockTypes = [
            'grass', 'dirt', 'stone', 'wood', 'leaves', 
            'brick', 'glass', 'stone_dark', 'stone_black',
            'red', 'blue', 'orange', 'purple', 'glowstone'
        ];
        const materials = {};
        const particles = []; 
        
        // Mobs
        let bunnies = [];
        const MAX_BUNNIES = 5; 
        
        let hotdogs = [];
        const MAX_HOTDOGS = 2; // Very rare

        // Optimization: Shared Geometries
        const sharedBlockGeometry = new THREE.BoxGeometry(1, 1, 1);
        const sharedParticleGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);

        // Data Structures
        const chunks = new Map(); 
        const worldData = new Map(); 
        let currentChunk = { x: 0, z: 0 };

        let skyMesh;
        const CLOUD_SPEED = 0.005;

        // --- Controls ---
        function initControls() {
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            const newBtn = document.getElementById('newBtn');
            const saveBtn = document.getElementById('saveBtn');
            const loadBtn = document.getElementById('loadBtn');
            const fileInput = document.getElementById('file-input');

            // Start Game
            instructions.addEventListener('click', function (e) {
                if (e.target.tagName === 'BUTTON') return;
                document.body.requestPointerLock();
            });
            
            newBtn.addEventListener('click', newGame);
            saveBtn.addEventListener('click', saveGame);
            loadBtn.addEventListener('click', () => { fileInput.click(); });
            fileInput.addEventListener('change', loadGame);

            document.addEventListener('pointerlockchange', function () {
                if (document.pointerLockElement === document.body) {
                    controls.enabled = true;
                    blocker.style.display = 'none';
                } else {
                    controls.enabled = false;
                    blocker.style.display = 'flex';
                }
            });

            const pitchObject = new THREE.Object3D();
            pitchObject.add(camera);
            
            const yawObject = new THREE.Object3D();
            yawObject.position.y = 20; 
            yawObject.add(pitchObject);
            
            scene.add(yawObject);

            controls = {
                enabled: false,
                getObject: function () { return yawObject; },
                getPitch: function() { return pitchObject; },
                getDirection: function(v) {
                    const direction = new THREE.Vector3(0, 0, -1);
                    const rotation = new THREE.Euler(0, 0, 0, 'YXZ');
                    rotation.set(pitchObject.rotation.x, yawObject.rotation.y, 0);
                    v.copy(direction).applyEuler(rotation);
                    return v;
                }
            };

            const onMouseMove = function (event) {
                if (controls.enabled === false) return;
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                yawObject.rotation.y -= movementX * 0.002;
                pitchObject.rotation.x -= movementY * 0.002;
                pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
            };

            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('wheel', function(event) {
                if (!controls.enabled) return;
                if (event.deltaY > 0) currentBlockIndex = (currentBlockIndex + 1) % blockTypes.length;
                else currentBlockIndex = (currentBlockIndex - 1 + blockTypes.length) % blockTypes.length;
                selectBlock(currentBlockIndex);
            });
        }
        
        // --- Save & Load Logic ---
        function newGame() {
            seedOffset.x = Math.floor(Math.random() * 100000);
            seedOffset.z = Math.floor(Math.random() * 100000);
            chunkMods.clear();
            resetWorld();
        }

        function resetWorld() {
            // 1. Clear visuals
            while(blockGroup.children.length > 0){ 
                blockGroup.remove(blockGroup.children[0]);
            }
            while(transparentBlockGroup.children.length > 0){
                transparentBlockGroup.remove(transparentBlockGroup.children[0]);
            }
            while(mobGroup.children.length > 0){
                mobGroup.remove(mobGroup.children[0]);
            }
            
            // 2. Clear Data
            worldData.clear();
            activeLights.clear(); // Clear lights
            chunks.clear();
            particles.length = 0; 
            bunnies = [];
            hotdogs = [];
            playerHealth = 100;
            updateHealthUI();

            // 3. Reset Player
            controls.getObject().position.set(0, 30, 0);
            controls.getObject().rotation.set(0,0,0);
            controls.getPitch().rotation.set(0,0,0);
            velocity.set(0,0,0);
            
            // 4. Force Regen
            currentChunk = { x: -999, z: -999 }; 
            updateChunks();
            
            // 5. Spawn Initial Bunnies
            spawnInitialMobs();
        }

        function saveGame() {
            const modsToSave = {};
            for(const [chunkKey, modMap] of chunkMods.entries()) {
                modsToSave[chunkKey] = Array.from(modMap.entries());
            }

            const saveData = {
                version: 2, 
                seed: seedOffset,
                player: {
                    position: controls.getObject().position,
                    rotation: {
                        y: controls.getObject().rotation.y,
                        x: controls.getPitch().rotation.x
                    }
                },
                mods: modsToSave 
            };

            const blob = new Blob([JSON.stringify(saveData)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pimcraft-world-${Date.now()}.pimcraft`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadGame(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    restoreState(data);
                } catch (err) {
                    alert("Failed to load map: Invalid file format");
                    console.error(err);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; 
        }

        function restoreState(data) {
            chunkMods.clear();
            while(blockGroup.children.length > 0) blockGroup.remove(blockGroup.children[0]);
            while(transparentBlockGroup.children.length > 0) transparentBlockGroup.remove(transparentBlockGroup.children[0]);
            worldData.clear();
            activeLights.clear();
            chunks.clear();
            particles.length = 0;
            bunnies = [];
            hotdogs = [];
            while(mobGroup.children.length > 0) mobGroup.remove(mobGroup.children[0]);

            if (data.seed) seedOffset = data.seed;
            else seedOffset = { x: 0, z: 0 };

            if (data.mods) {
                for (const key in data.mods) {
                    chunkMods.set(key, new Map(data.mods[key]));
                }
            }

            if (data.player) {
                controls.getObject().position.copy(data.player.position);
                controls.getObject().rotation.y = data.player.rotation.y;
                controls.getPitch().rotation.x = data.player.rotation.x;
                velocity.set(0,0,0);
            }
            
            currentChunk = { x: -999, z: -999 };
            updateChunks();
            spawnInitialMobs(); 
            
            alert("World Loaded Successfully!");
        }

        // --- Pickaxe ---
        function initPickaxe() {
            pickaxeGroup = new THREE.Group();
            pickaxeGroup.position.set(0.5, -0.4, -0.8);
            pickaxeGroup.rotation.set(0, -0.2, 0.2); 
            camera.add(pickaxeGroup);

            const handleGeo = new THREE.BoxGeometry(0.04, 0.6, 0.04);
            const handleMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = 0;
            pickaxeGroup.add(handle);

            const headGeo = new THREE.BoxGeometry(0.4, 0.08, 0.08);
            const headMat = new THREE.MeshLambertMaterial({ color: 0x888888 }); 
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.3;
            pickaxeGroup.add(head);
            
            const tip1 = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.08), headMat);
            tip1.position.set(0.2, 0.25, 0);
            pickaxeGroup.add(tip1);
            
            const tip2 = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.08), headMat);
            tip2.position.set(-0.2, 0.25, 0);
            pickaxeGroup.add(tip2);
        }

        function animatePickaxe(delta) {
            if (isMining) {
                miningTimer += delta * 25; 
                
                const swing = Math.sin(miningTimer);
                
                pickaxeGroup.rotation.x = -swing * 1.5; 
                pickaxeGroup.rotation.y = -0.2 + swing * 0.5; 
                pickaxeGroup.position.z = -0.8 - swing * 0.4;
                pickaxeGroup.position.y = -0.4 - swing * 0.2;
                
                if (miningTimer > Math.PI) {
                    if (isLeftMouseDown) {
                        miningTimer = 0;
                    } else {
                        isMining = false;
                        miningTimer = 0;
                        pickaxeGroup.position.set(0.5, -0.4, -0.8);
                        pickaxeGroup.rotation.set(0, -0.2, 0.2);
                    }
                }
            }
        }

        // --- Particles ---
        function createParticles(pos, color) {
            const particleCount = 5; 
            const material = new THREE.MeshBasicMaterial({ color: color });

            for (let i = 0; i < particleCount; i++) {
                const mesh = new THREE.Mesh(sharedParticleGeometry, material);
                mesh.position.copy(pos).add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                ));
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    (Math.random() * 4),
                    (Math.random() - 0.5) * 4
                );

                scene.add(mesh);
                particles.push({ mesh, velocity, life: 1.0 });
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= delta * 2.0; 
                p.velocity.y -= 9.8 * delta;
                p.mesh.position.addScaledVector(p.velocity, delta);
                p.mesh.rotation.x += p.velocity.z * delta;
                p.mesh.rotation.y += p.velocity.x * delta;
                p.mesh.scale.setScalar(p.life);

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // --- MOBS ---
        
        // 1. BUNNY
        function createBunnyMesh() {
            const group = new THREE.Group();
            const matWhite = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const matPink = new THREE.MeshLambertMaterial({ color: 0xffb6c1 });
            const matRed = new THREE.MeshBasicMaterial({ color: 0xff0000 }); 

            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.6), matWhite);
            body.position.y = 0.2;
            group.add(body);
            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.35), matWhite);
            head.position.set(0, 0.5, 0.3);
            group.add(head);
            // Ears
            const earGeo = new THREE.BoxGeometry(0.08, 0.4, 0.1);
            const earL = new THREE.Mesh(earGeo, matWhite);
            earL.position.set(0.1, 0.8, 0.3);
            group.add(earL);
            const earInner = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.3, 0.05), matPink);
            earInner.position.set(0.1, 0.8, 0.33);
            group.add(earInner);
            const earR = new THREE.Mesh(earGeo, matWhite);
            earR.position.set(-0.1, 0.8, 0.3);
            group.add(earR);
            const earInnerR = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.3, 0.05), matPink);
            earInnerR.position.set(-0.1, 0.8, 0.33);
            group.add(earInnerR);
            // Eyes
            const eyeGeo = new THREE.PlaneGeometry(0.08, 0.08);
            const eyeL = new THREE.Mesh(eyeGeo, matRed);
            eyeL.position.set(0.08, 0.55, 0.48);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, matRed);
            eyeR.position.set(-0.08, 0.55, 0.48);
            group.add(eyeR);
            
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshBasicMaterial({visible: false}));
            hitbox.position.y = 0.4;
            hitbox.name = "mobHitbox";
            hitbox.userData = { parent: group, type: 'bunny' };
            group.add(hitbox);
            return group;
        }

        // 2. DANCING HOT DOG
        function createHotDogMesh() {
            const group = new THREE.Group();
            const matBun = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 }); // Wheat
            const matMeat = new THREE.MeshLambertMaterial({ color: 0xA52A2A }); // Brown/Red
            const matMustard = new THREE.MeshLambertMaterial({ color: 0xFFD700 }); // Gold
            const matBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });

            // Sausage
            const sausage = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), matMeat);
            sausage.position.y = 0.6;
            group.add(sausage);

            // Buns
            const bunL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.35), matBun);
            bunL.position.set(0.2, 0.6, 0);
            group.add(bunL);
            const bunR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.35), matBun);
            bunR.position.set(-0.2, 0.6, 0);
            group.add(bunR);

            // Mustard
            const mustard = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.05), matMustard);
            mustard.position.set(0, 0.6, 0.16);
            group.add(mustard);

            // Sunglasses
            const glasses = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.1, 0.05), matBlack);
            glasses.position.set(0, 0.8, 0.18);
            group.add(glasses);

            // Limbs (Arms/Legs) - Stick style
            const limbGeo = new THREE.BoxGeometry(0.05, 0.3, 0.05);
            
            const armL = new THREE.Mesh(limbGeo, matBun);
            armL.position.set(0.35, 0.7, 0);
            armL.rotation.z = -0.5;
            group.add(armL);

            const armR = new THREE.Mesh(limbGeo, matBun);
            armR.position.set(-0.35, 0.7, 0);
            armR.rotation.z = 0.5;
            group.add(armR);

            const legL = new THREE.Mesh(limbGeo, matBun);
            legL.position.set(0.1, 0.15, 0);
            group.add(legL);

            const legR = new THREE.Mesh(limbGeo, matBun);
            legR.position.set(-0.1, 0.15, 0);
            group.add(legR);

            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.8), new THREE.MeshBasicMaterial({visible: false}));
            hitbox.position.y = 0.6;
            hitbox.name = "mobHitbox";
            hitbox.userData = { parent: group, type: 'hotdog' };
            group.add(hitbox);

            return group;
        }

        function spawnInitialMobs() {
            for(let i=0; i<MAX_BUNNIES; i++) spawnNewMob('bunny');
            for(let i=0; i<MAX_HOTDOGS; i++) spawnNewMob('hotdog');
        }

        function spawnNewMob(type) {
            const playerPos = controls.getObject().position;
            
            // Spawn radius
            const dist = 30 + Math.random() * 40; 
            const angle = Math.random() * Math.PI * 2;
            
            const x = playerPos.x + Math.cos(angle) * dist;
            const z = playerPos.z + Math.sin(angle) * dist;
            const y = getTerrainHeight(Math.floor(x), Math.floor(z)) + 1.5;

            let mesh;
            if (type === 'bunny') {
                mesh = createBunnyMesh();
                mesh.position.set(x, y, z);
                mobGroup.add(mesh);
                bunnies.push({
                    mesh: mesh,
                    health: 3,
                    velocity: new THREE.Vector3(),
                    jumpTimer: Math.random(),
                    onGround: false,
                    aggro: false,
                    type: 'bunny',
                    targetLight: null,
                    lightScanTimer: 0
                });
            } else if (type === 'hotdog') {
                mesh = createHotDogMesh();
                mesh.position.set(x, y, z);
                mobGroup.add(mesh);
                hotdogs.push({
                    mesh: mesh,
                    health: 3, // Takes a few hits
                    velocity: new THREE.Vector3(),
                    jumpTimer: Math.random(),
                    onGround: false,
                    scared: false,
                    type: 'hotdog',
                    danceOffset: Math.random() * 100,
                    targetLight: null,
                    lightScanTimer: 0
                });
            }
        }

        function updateMobs(delta) {
            const playerPos = controls.getObject().position;
            document.getElementById('bunny-count').innerText = bunnies.length;

            // 1. Maintain Populations
            if (bunnies.length < MAX_BUNNIES && Math.random() < 0.01) spawnNewMob('bunny');
            if (hotdogs.length < MAX_HOTDOGS && Math.random() < 0.005) spawnNewMob('hotdog');

            // 2. Update Bunnies
            updateBunnyLogic(delta, playerPos);
            // 3. Update Hot Dogs
            updateHotDogLogic(delta, playerPos);
        }
        
        function findNearestLight(mobPos, range) {
             let nearest = null;
             let minDstSq = range * range;
             
             for(const key of activeLights) {
                 const [lx, ly, lz] = key.split(',').map(Number);
                 // Distance Check (Squared)
                 const dx = lx - mobPos.x;
                 const dy = ly - mobPos.y;
                 const dz = lz - mobPos.z;
                 const dSq = dx*dx + dy*dy + dz*dz;
                 
                 if (dSq < minDstSq) {
                     minDstSq = dSq;
                     nearest = new THREE.Vector3(lx, ly, lz);
                 }
             }
             return nearest;
        }

        function updateBunnyLogic(delta, playerPos) {
            for (let i = bunnies.length - 1; i >= 0; i--) {
                const b = bunnies[i];
                applyPhysics(b, delta);
                
                const dist = b.mesh.position.distanceTo(playerPos);
                
                // Light Scanning
                b.lightScanTimer -= delta;
                if (b.lightScanTimer <= 0) {
                    b.lightScanTimer = 1.0 + Math.random(); // Check every second
                    b.targetLight = findNearestLight(b.mesh.position, 20); // 20 block range
                }
                
                // Aggro Overrides Light
                if (dist < 12) {
                    b.aggro = true;
                    b.targetLight = null; // Forget light if angry
                    b.mesh.lookAt(playerPos.x, b.mesh.position.y, playerPos.z);
                } else {
                    b.aggro = false;
                    if (b.targetLight) {
                         b.mesh.lookAt(b.targetLight.x, b.mesh.position.y, b.targetLight.z);
                    }
                }

                b.jumpTimer -= delta;
                if (b.onGround && b.jumpTimer <= 0) {
                    b.jumpTimer = b.aggro ? 0.5 : 2.0 + Math.random();
                    b.velocity.y = 8;
                    b.onGround = false;

                    const speed = 3.0;
                    if (b.aggro) {
                        const dx = playerPos.x - b.mesh.position.x;
                        const dz = playerPos.z - b.mesh.position.z;
                        const len = Math.sqrt(dx*dx + dz*dz);
                        if (len > 0) {
                            b.velocity.x = (dx/len) * speed * 1.5;
                            b.velocity.z = (dz/len) * speed * 1.5;
                        }
                    } else if (b.targetLight) {
                        // Move towards light
                        const dx = b.targetLight.x - b.mesh.position.x;
                        const dz = b.targetLight.z - b.mesh.position.z;
                        const len = Math.sqrt(dx*dx + dz*dz);
                        if (len > 1.0) { // Don't hump the block
                             b.velocity.x = (dx/len) * speed;
                             b.velocity.z = (dz/len) * speed;
                        } else {
                             b.velocity.x = 0;
                             b.velocity.z = 0;
                        }
                    } else {
                        const angle = Math.random() * Math.PI * 2;
                        b.velocity.x = Math.cos(angle) * speed;
                        b.velocity.z = Math.sin(angle) * speed;
                        b.mesh.rotation.y = -angle + Math.PI/2;
                    }
                }

                if (dist < 1.5) damagePlayer();
                
                if (dist > 70) {
                    mobGroup.remove(b.mesh);
                    bunnies.splice(i, 1);
                }
            }
        }

        function updateHotDogLogic(delta, playerPos) {
            const scareRange = 15;
            const runSpeed = 6.5; // Faster than player

            for (let i = hotdogs.length - 1; i >= 0; i--) {
                const h = hotdogs[i];
                applyPhysics(h, delta);

                const dist = h.mesh.position.distanceTo(playerPos);

                // Light Scanning
                h.lightScanTimer -= delta;
                if (h.lightScanTimer <= 0) {
                    h.lightScanTimer = 1.0 + Math.random();
                    h.targetLight = findNearestLight(h.mesh.position, 25);
                }

                // Dancing Animation (Idle OR Near Light)
                let isDancing = false;
                if (!h.scared && h.onGround) {
                     if (h.targetLight) {
                         // Dance near light
                         const dToLight = h.mesh.position.distanceTo(h.targetLight);
                         if (dToLight < 3) isDancing = true;
                     } else {
                         // Random dance occasionally? No, mostly idle
                         isDancing = true;
                     }
                }
                
                if (isDancing) {
                    h.mesh.rotation.z = Math.sin(performance.now() * 0.01 + h.danceOffset) * 0.2;
                    if (h.targetLight) {
                        // Spin fast if loving light
                        h.mesh.rotation.y += delta * 5;
                    } else {
                        h.mesh.rotation.y += delta;
                    }
                } else {
                    h.mesh.rotation.z = 0;
                }

                // Scare Logic (Overrides Light)
                if (dist < scareRange) {
                    h.scared = true;
                    h.targetLight = null; // Forget light, run!
                    // Look AWAY from player
                    h.mesh.lookAt(2 * h.mesh.position.x - playerPos.x, h.mesh.position.y, 2 * h.mesh.position.z - playerPos.z);
                } else if (dist > scareRange * 2) {
                    h.scared = false;
                }

                h.jumpTimer -= delta;
                if (h.onGround && h.jumpTimer <= 0) {
                    if (h.scared) {
                        // RUN AWAY
                        h.jumpTimer = 0.3; // Hop fast
                        h.velocity.y = 6;
                        h.onGround = false;
                        
                        const dx = h.mesh.position.x - playerPos.x; // Vector pointing away
                        const dz = h.mesh.position.z - playerPos.z;
                        const len = Math.sqrt(dx*dx + dz*dz);
                        if (len > 0) {
                            h.velocity.x = (dx/len) * runSpeed;
                            h.velocity.z = (dz/len) * runSpeed;
                        }
                    } else if (h.targetLight) {
                        // Run to light!
                         const dx = h.targetLight.x - h.mesh.position.x;
                         const dz = h.targetLight.z - h.mesh.position.z;
                         const len = Math.sqrt(dx*dx + dz*dz);
                         if (len > 1.5) {
                              h.jumpTimer = 0.5;
                              h.velocity.y = 6;
                              h.onGround = false;
                              h.velocity.x = (dx/len) * runSpeed;
                              h.velocity.z = (dz/len) * runSpeed;
                              h.mesh.lookAt(h.targetLight.x, h.mesh.position.y, h.targetLight.z);
                         } else {
                              // Arrived at light
                              h.velocity.x = 0;
                              h.velocity.z = 0;
                              // Just chill here
                         }
                    } else {
                        // Just chill/dance, maybe small hop
                        h.jumpTimer = 1.0 + Math.random() * 2.0;
                        if (Math.random() > 0.5) {
                            h.velocity.y = 5;
                            h.onGround = false;
                            // Random small move
                            const angle = Math.random() * Math.PI * 2;
                            h.velocity.x = Math.cos(angle) * 2;
                            h.velocity.z = Math.sin(angle) * 2;
                        }
                    }
                }

                // Despawn far away
                if (dist > 90) {
                    mobGroup.remove(h.mesh);
                    hotdogs.splice(i, 1);
                }
            }
        }

        function applyPhysics(mob, delta) {
            mob.velocity.y -= GRAVITY * delta;
            mob.mesh.position.addScaledVector(mob.velocity, delta);

            if (mob.onGround) {
                mob.velocity.x *= 0.8;
                mob.velocity.z *= 0.8;
            }

            const terrainH = getTerrainHeight(Math.floor(mob.mesh.position.x), Math.floor(mob.mesh.position.z));
            
            // Ground Collision
            if (mob.mesh.position.y < terrainH + 0.5) {
                mob.mesh.position.y = terrainH + 0.5;
                mob.velocity.y = 0;
                mob.onGround = true;
            } else {
                // Check block collision
                if (checkPlayerCollision(mob.mesh.position.x, mob.mesh.position.y, mob.mesh.position.z)) {
                    mob.mesh.position.y += 0.1;
                    mob.onGround = true;
                    mob.velocity.y = 0;
                } else {
                    mob.onGround = false;
                }
            }
        }

        function damagePlayer() {
            const now = performance.now();
            if (now - lastHitTime > 1000) { 
                lastHitTime = now;
                playerHealth -= 10;
                updateHealthUI();
                
                const overlay = document.getElementById('damage-overlay');
                overlay.style.opacity = 1;
                setTimeout(() => overlay.style.opacity = 0, 200);

                velocity.y = 5;
                velocity.x += (Math.random()-0.5)*10;
                velocity.z += (Math.random()-0.5)*10;

                if (playerHealth <= 0) {
                    alert("GAME OVER!");
                    resetWorld();
                }
            }
        }
        
        function healPlayer(amount) {
            playerHealth = Math.min(100, playerHealth + amount);
            updateHealthUI();
            const overlay = document.getElementById('heal-overlay');
            overlay.style.opacity = 1;
            setTimeout(() => overlay.style.opacity = 0, 400);
        }

        function updateHealthUI() {
            document.getElementById('hp-val').innerText = playerHealth;
            document.getElementById('health-bar').style.width = playerHealth + '%';
        }

        // --- Texture Generation ---
        function createTexture(baseColor, isBrick = false, isGlass = false, isGlow = false) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, size, size);

            if (isGlass) {
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 4;
                ctx.strokeRect(0,0,size,size);
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.moveTo(10, 54); ctx.lineTo(20, 44);
                ctx.moveTo(15, 59); ctx.lineTo(35, 39);
                ctx.stroke();
            } else if (isBrick) {
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(0, 15, 64, 2); ctx.fillRect(0, 31, 64, 2); ctx.fillRect(0, 47, 64, 2);
                ctx.fillRect(32, 0, 2, 15); ctx.fillRect(10, 15, 2, 16); ctx.fillRect(42, 15, 2, 16);
                ctx.fillRect(32, 31, 2, 16); ctx.fillRect(10, 47, 2, 17); ctx.fillRect(42, 47, 2, 17);
            } else if (isGlow) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                for(let i=0; i<20; i++) {
                    const x = Math.random() * 64;
                    const y = Math.random() * 64;
                    ctx.fillRect(x,y,4,4);
                }
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 4;
                ctx.strokeRect(0,0,size,size);
            } else {
                for (let i = 0; i < 200; i++) {
                    const x = Math.floor(Math.random() * size);
                    const y = Math.floor(Math.random() * size);
                    const w = Math.floor(Math.random() * 8) + 2;
                    const h = Math.floor(Math.random() * 8) + 2;
                    ctx.fillStyle = Math.random() > 0.5 ? `rgba(0,0,0, ${Math.random() * 0.15})` : `rgba(255,255,255, ${Math.random() * 0.15})`;
                    ctx.fillRect(x, y, w, h);
                }
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 4;
                ctx.strokeRect(0,0,size,size);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function initMaterials() {
            const texGrassTop = createTexture('#5C9E65');
            const texGrassSide = createTexture('#4E804A'); 
            const texDirt = createTexture('#6B543E');
            const texStone = createTexture('#7D7D7D');
            const texStoneDark = createTexture('#555555');
            const texStoneBlack = createTexture('#222222');
            const texWood = createTexture('#5C4033');
            const texLeaves = createTexture('#2D5A27');
            const texBrick = createTexture('#A05040', true);
            const texGlass = createTexture('#ADD8E6', false, true);
            const texGlow = createTexture('#FFD700', false, false, true);
            
            const texRed = createTexture('#D22B2B');
            const texBlue = createTexture('#0000CD');
            const texOrange = createTexture('#FF8C00');
            const texPurple = createTexture('#800080');

            materials.grass = [
                new THREE.MeshLambertMaterial({ map: texGrassSide }), new THREE.MeshLambertMaterial({ map: texGrassSide }),
                new THREE.MeshLambertMaterial({ map: texGrassTop }), new THREE.MeshLambertMaterial({ map: texDirt }),
                new THREE.MeshLambertMaterial({ map: texGrassSide }), new THREE.MeshLambertMaterial({ map: texGrassSide })
            ];
            materials.dirt = new THREE.MeshLambertMaterial({ map: texDirt });
            materials.stone = new THREE.MeshLambertMaterial({ map: texStone });
            materials.wood = new THREE.MeshLambertMaterial({ map: texWood });
            materials.leaves = new THREE.MeshLambertMaterial({ map: texLeaves });
            materials.brick = new THREE.MeshLambertMaterial({ map: texBrick });
            materials.glass = new THREE.MeshLambertMaterial({ map: texGlass, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            materials.stone_dark = new THREE.MeshLambertMaterial({ map: texStoneDark });
            materials.stone_black = new THREE.MeshLambertMaterial({ map: texStoneBlack });
            materials.red = new THREE.MeshLambertMaterial({ map: texRed });
            materials.blue = new THREE.MeshLambertMaterial({ map: texBlue });
            materials.orange = new THREE.MeshLambertMaterial({ map: texOrange });
            materials.purple = new THREE.MeshLambertMaterial({ map: texPurple });
            materials.glowstone = new THREE.MeshLambertMaterial({ map: texGlow, emissive: 0xFFFF00, emissiveIntensity: 0.5 });
        }

        function initSky() {
            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `;
            const fragmentShader = `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize( vWorldPosition ).y;
                    gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h + offset, 0.0 ), exponent ), 0.0 ) ), 1.0 );
                }
            `;
            const uniforms = {
                "topColor": { value: new THREE.Color(0x95D8EE) },
                "bottomColor": { value: new THREE.Color(0x87CEEB) },
                "offset": { value: 0 },
                "exponent": { value: 0.6 }
            };
            const skyGeo = new THREE.SphereGeometry(400, 32, 15);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });
            skyMesh = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skyMesh);

            const cloudGeo = new THREE.PlaneGeometry(300, 300);
            const cloudCanvas = document.createElement('canvas');
            cloudCanvas.width = 128;
            cloudCanvas.height = 128;
            const ctx = cloudCanvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,128,128);
            for(let i=0; i<400; i++) {
                const x = Math.random() * 128;
                const y = Math.random() * 128;
                const w = Math.random() * 20;
                const h = Math.random() * 10;
                ctx.globalAlpha = Math.random() * 0.1 + 0.05;
                ctx.fillRect(x,y,w,h);
            }
            const cloudTexture = new THREE.CanvasTexture(cloudCanvas);
            cloudTexture.magFilter = THREE.NearestFilter;
            cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;

            const cloudMaterial = new THREE.MeshBasicMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.8,
                side: THREE.FrontSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            for (let i = 0; i < 8; i++) {
                const cloud = new THREE.Mesh(cloudGeo, cloudMaterial);
                cloud.position.set(Math.random()*400-200, 120+Math.random()*20, Math.random()*400-200);
                cloud.rotation.x = -Math.PI / 2;
                scene.add(cloud);
            }
        }

        // --- Physics & World Data ---
        function getBlockKey(x, y, z) { return `${x},${y},${z}`; }
        function hasBlockData(x, y, z) { return worldData.has(getBlockKey(x, y, z)); }
        function getBlockData(x, y, z) { return worldData.get(getBlockKey(x, y, z)); }

        function checkPlayerCollision(x, y, z) {
            const minX = Math.floor(x - PLAYER_RADIUS);
            const maxX = Math.floor(x + PLAYER_RADIUS);
            const minZ = Math.floor(z - PLAYER_RADIUS);
            const maxZ = Math.floor(z + PLAYER_RADIUS);
            const minY = Math.floor(y - PLAYER_HEIGHT);
            const maxY = Math.floor(y); 

            for (let bx = minX; bx <= maxX; bx++) {
                for (let bz = minZ; bz <= maxZ; bz++) {
                    for (let by = minY; by <= maxY; by++) {
                        if (hasBlockData(bx, by, bz)) return true;
                    }
                }
            }
            return false;
        }

        function getTerrainHeight(x, z) {
            const sx = x + seedOffset.x;
            const sz = z + seedOffset.z;
            const h1 = (Math.sin(sx / 25) * Math.cos(sz / 25)) * 6;
            const h2 = (Math.sin(sx / 8) * Math.cos(sz / 8)) * 2;
            const h3 = (Math.sin(sx / 2) * Math.sin(sz / 3)) * 0.5;
            return Math.floor(h1 + h2 + h3);
        }

        // Simple pseudo-random function for tree placement based on coordinates and seed
        function pseudoRandom(x, z) {
            const sx = x + seedOffset.x;
            const sz = z + seedOffset.z;
            // A simple hashing-like mechanism using sin to get a value between 0 and 1
            let val = Math.sin(sx * 12.9898 + sz * 78.233) * 43758.5453;
            return val - Math.floor(val); 
        }

        // --- Mod Logic ---
        function getChunkKeyFromCoords(x, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            return `${cx},${cz}`;
        }
        
        function recordModification(x, y, z, type) {
            const chunkKey = getChunkKeyFromCoords(x, z);
            if (!chunkMods.has(chunkKey)) chunkMods.set(chunkKey, new Map());
            chunkMods.get(chunkKey).set(`${x},${y},${z}`, type);
        }

        // --- Core Block Logic ---
        
        function createBlock(x, y, z, type, renderNow = true) {
            const key = getBlockKey(x, y, z);
            
            if (worldData.has(key)) {
                const oldEntry = worldData.get(key);
                if (oldEntry.mesh && oldEntry.mesh.parent) {
                    oldEntry.mesh.parent.remove(oldEntry.mesh);
                }
            }

            const entry = { type: type, mesh: null };
            worldData.set(key, entry);
            
            // NEW: Track glowstone for mob AI
            if (type === 'glowstone') {
                activeLights.add(key);
            }

            if (renderNow) {
                return renderBlock(x, y, z, entry);
            }
            return null;
        }

        function renderBlock(x, y, z, entry) {
            if (entry.mesh) return entry.mesh; 

            const mesh = new THREE.Mesh(sharedBlockGeometry, materials[entry.type]);
            mesh.position.set(x, y, z);
            
            if (entry.type === 'glowstone') {
                const light = new THREE.PointLight(0xFFFF00, 1, 8); 
                mesh.add(light);
            } else {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
            }

            if (entry.type === 'glass') transparentBlockGroup.add(mesh);
            else blockGroup.add(mesh);
            
            entry.mesh = mesh;
            return mesh;
        }

        function revealNeighbors(x, y, z) {
            const dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
            dirs.forEach(d => {
                const nx = x + d[0], ny = y + d[1], nz = z + d[2];
                const entry = getBlockData(nx, ny, nz);
                if (entry && !entry.mesh) {
                    renderBlock(nx, ny, nz, entry);
                }
            });
        }

        function generateChunk(cx, cz) {
            const chunkBlocks = []; 
            const startX = cx * CHUNK_SIZE;
            const startZ = cz * CHUNK_SIZE;
            
            const chunkKey = `${cx},${cz}`;
            const mods = chunkMods.get(chunkKey);

            const isTransparent = (nx, ny, nz) => {
                const nCk = getChunkKeyFromCoords(nx, nz);
                if (chunkMods.has(nCk)) {
                    const nm = chunkMods.get(nCk);
                    const nk = `${nx},${ny},${nz}`;
                    if (nm.has(nk)) {
                         const t = nm.get(nk);
                         if (t === 'air' || t === 'glass') return true;
                         return false;
                    }
                }
                
                const nh = getTerrainHeight(nx, nz);
                if (ny > nh) return true; 
                return false; 
            };

            for (let x = startX; x < startX + CHUNK_SIZE; x++) {
                for (let z = startZ; z < startZ + CHUNK_SIZE; z++) {
                    const h = getTerrainHeight(x, z);
                    
                    for (let y = h; y >= -WORLD_DEPTH; y--) {
                        const blockKey = `${x},${y},${z}`;
                        let type = 'stone';
                        
                        if (y === h) type = 'grass';
                        else if (y > h - 4) type = 'dirt';
                        else if (y < -30 && Math.random() < 0.05) type = 'stone_black'; 
                        else if (y < -10 && Math.random() < 0.05) type = 'stone_dark';

                        if (mods && mods.has(blockKey)) {
                            type = mods.get(blockKey);
                        }

                        if (type === 'air') continue;

                        let exposed = false;
                        if (y === h) exposed = true;
                        else if (mods && mods.has(blockKey)) exposed = true; 
                        else {
                             if (isTransparent(x+1, y, z)) exposed = true;
                             else if (isTransparent(x-1, y, z)) exposed = true;
                             else if (isTransparent(x, y, z+1)) exposed = true;
                             else if (isTransparent(x, y, z-1)) exposed = true;
                             else if (isTransparent(x, y+1, z)) exposed = true;
                             else if (isTransparent(x, y-1, z)) exposed = true;
                        }

                        const mesh = createBlock(x, y, z, type, exposed);
                        if (mesh) chunkBlocks.push(mesh);
                    }

                    // Trees
                    const treeKey = `${x},${h+1},${z}`;
                    let allowTree = true;
                    if (mods && mods.has(treeKey) && mods.get(treeKey) !== 'wood') allowTree = false;

                    // Use pseudoRandom for more random tree placement
                    // Reduced density by 15% (from 0.02 down to 0.017)
                    if (allowTree && pseudoRandom(x, z) < 0.017) {
                        createTree(x, h + 1, z, mods);
                    }
                }
            }
            
            if (mods) {
                for (const [blockKey, type] of mods) {
                    if (type === 'air') continue;
                    if (!worldData.has(blockKey)) {
                        const [bx, by, bz] = blockKey.split(',').map(Number);
                        if (Math.floor(bx/CHUNK_SIZE) === cx && Math.floor(bz/CHUNK_SIZE) === cz) {
                            const mesh = createBlock(bx, by, bz, type, true);
                            if (mesh) chunkBlocks.push(mesh);
                        }
                    }
                }
            }

            return chunkBlocks;
        }

        function createTree(x, y, z, mods) {
            const check = (bx, by, bz, type) => {
                const k = `${bx},${by},${bz}`;
                if (mods && mods.has(k)) {
                    if (mods.get(k) === 'air') return; 
                }
                createBlock(bx, by, bz, type, true);
            };

            const height = 3 + (Math.abs(x * z) % 3);
            for (let i = 0; i < height; i++) check(x, y + i, z, 'wood');
            for (let lx = -2; lx <= 2; lx++) {
                for (let ly = 0; ly <= 2; ly++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        if (Math.abs(lx) + Math.abs(ly) + Math.abs(lz) > 3) continue;
                        check(x + lx, y + height - 1 + ly, z + lz, 'leaves');
                    }
                }
            }
        }

        function updateChunks() {
            const pos = controls.getObject().position;
            const cx = Math.floor(pos.x / CHUNK_SIZE);
            const cz = Math.floor(pos.z / CHUNK_SIZE);

            if (cx === currentChunk.x && cz === currentChunk.z && chunks.size > 0) return;

            currentChunk = { x: cx, z: cz };
            const activeKeys = new Set();

            for (let x = cx - RENDER_DISTANCE; x <= cx + RENDER_DISTANCE; x++) {
                for (let z = cz - RENDER_DISTANCE; z <= cz + RENDER_DISTANCE; z++) {
                    const key = `${x},${z}`;
                    activeKeys.add(key);
                    if (!chunks.has(key)) {
                        const newBlocks = generateChunk(x, z);
                        chunks.set(key, newBlocks);
                    }
                }
            }
            
            for (const [key, blocks] of chunks) {
                if (!activeKeys.has(key)) {
                    if (Array.isArray(blocks)) {
                        blocks.forEach(block => {
                            if (block && block.parent) {
                                block.parent.remove(block);
                                const bx = block.position.x;
                                const by = block.position.y;
                                const bz = block.position.z;
                                const k = getBlockKey(bx, by, bz);
                                // NEW: Check if removing glowstone from unloaded chunk
                                const data = worldData.get(k);
                                if (data && data.type === 'glowstone') {
                                    activeLights.delete(k);
                                }
                                worldData.delete(k);
                            }
                        });
                    }
                    chunks.delete(key);
                }
            }
            
            // document.getElementById('chunkCount').innerText = chunks.size;
        }

        function initToolbar() {
            const toolbar = document.getElementById('toolbar');
            toolbar.innerHTML = ''; 
            blockTypes.forEach((type, index) => {
                const slot = document.createElement('div');
                slot.className = 'slot';
                if (index === 0) slot.classList.add('active');
                slot.id = `slot${index}`;
                const num = document.createElement('span');
                num.className = 'slot-number';
                num.innerText = index + 1;
                if (index >= 9) num.innerText = ""; 
                const canvas = document.createElement('canvas');
                canvas.id = `blockIcon${index}`;
                slot.appendChild(num);
                slot.appendChild(canvas);
                toolbar.appendChild(slot);
                renderBlockIcon(`blockIcon${index}`, type);
                slot.addEventListener('mousedown', () => selectBlock(index));
            });
        }

        function renderBlockIcon(canvasId, blockType) {
            const canvas = document.getElementById(canvasId);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
            renderer.setSize(40, 40);
            const iconScene = new THREE.Scene();
            const iconCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 100);
            iconCamera.position.set(0.8, 0.8, 0.8);
            iconCamera.lookAt(0, 0, 0);
            const light = new THREE.AmbientLight(0xffffff, 1.0);
            iconScene.add(light);
            const mesh = new THREE.Mesh(sharedBlockGeometry.clone().scale(0.8, 0.8, 0.8), materials[blockType]);
            iconScene.add(mesh);
            renderer.render(iconScene, iconCamera);
        }

        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 1000);
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, (RENDER_DISTANCE * CHUNK_SIZE) - 5);

            blockGroup = new THREE.Group();
            transparentBlockGroup = new THREE.Group();
            mobGroup = new THREE.Group();
            
            scene.add(blockGroup);
            scene.add(transparentBlockGroup);
            scene.add(mobGroup);

            ambientLight = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.8);
            ambientLight.position.set(0.5, 1, 0.75);
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(50, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            initMaterials();
            initPickaxe();
            initControls();
            initSky();
            initToolbar();
            
            updateChunks(); 
            spawnInitialMobs();

            raycaster = new THREE.Raycaster();
            raycaster.far = 6; 
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            
            window.addEventListener('resize', onWindowResize);
            
            selectBlock(0);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': 
                    if (!isFlying && canJump) { 
                        velocity.y = PLAYER_JUMP; 
                        canJump = false; 
                    }
                    moveUp = true; 
                    break;
                case 'ShiftLeft': case 'ShiftRight': moveDown = true; break;
                case 'KeyF': toggleFlying(); break; // Re-enabled!
            }
            
            if (event.key >= '1' && event.key <= '9') {
                const idx = parseInt(event.key) - 1;
                if (idx < blockTypes.length) selectBlock(idx);
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'Space': moveUp = false; break;
                case 'ShiftLeft': case 'ShiftRight': moveDown = false; break;
            }
        }

        function toggleFlying() {
            isFlying = !isFlying;
            velocity.y = 0; 
            const status = document.getElementById('fly-status');
            if(isFlying) {
                status.innerText = "ON";
                status.style.color = "#00FF00";
            } else {
                status.innerText = "OFF";
                status.style.color = "yellow";
            }
        }

        function selectBlock(index) {
            currentBlockIndex = index;
            const type = blockTypes[index];
            const name = type.replace('_', ' ');
            document.getElementById('blockName').innerText = name.charAt(0).toUpperCase() + name.slice(1);
            
            document.querySelectorAll('.slot').forEach((el, i) => {
                if (i === index) {
                    el.classList.add('active');
                    el.scrollIntoView({ behavior: "smooth", inline: "center" });
                }
                else el.classList.remove('active');
            });
        }

        function onMouseDown(event) {
            if (!controls.enabled) return;
            
            if (event.button === 0) {
                isLeftMouseDown = true;
                isMining = true; // Start anim
                if (actionCooldown <= 0) {
                    performAction(0);
                    actionCooldown = ACTION_DELAY;
                }
            }
            
            if (event.button === 2) {
                isRightMouseDown = true;
                if (actionCooldown <= 0) {
                    performAction(2);
                    actionCooldown = ACTION_DELAY;
                }
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) isLeftMouseDown = false;
            if (event.button === 2) isRightMouseDown = false;
        }

        // Consolidated action logic
        function performAction(button) {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            if (button === 0) {
                // Attack Check First
                // Raycast against mobs
                const mobIntersects = raycaster.intersectObjects(mobGroup.children, true);
                if (mobIntersects.length > 0 && mobIntersects[0].distance < 4) {
                    const hitObj = mobIntersects[0].object;
                    
                    // Find parent wrapper
                    let hitWrapper = hitObj;
                    while(hitWrapper.parent && hitWrapper.parent !== mobGroup) {
                        hitWrapper = hitWrapper.parent;
                    }
                    
                    // Check Bunnies
                    const bunnyData = bunnies.find(b => b.mesh === hitWrapper);
                    if (bunnyData) {
                        bunnyData.health--;
                        createParticles(mobIntersects[0].point, 0xff0000);
                        bunnyData.velocity.add(controls.getDirection(new THREE.Vector3()).multiplyScalar(10));
                        bunnyData.velocity.y = 5;
                        bunnyData.aggro = true;
                        hitWrapper.traverse(c => {
                           if (c.material && c.material.emissive) {
                               const old = c.material.emissive.getHex();
                               c.material.emissive.setHex(0xff0000);
                               setTimeout(() => { if(c.material) c.material.emissive.setHex(old); }, 100);
                           } 
                        });
                        if (bunnyData.health <= 0) {
                            mobGroup.remove(hitWrapper);
                            bunnies = bunnies.filter(b => b !== bunnyData);
                        }
                        return; 
                    }

                    // Check Hot Dogs
                    const hotdogData = hotdogs.find(h => h.mesh === hitWrapper);
                    if (hotdogData) {
                        hotdogData.health--;
                        createParticles(mobIntersects[0].point, 0xFFD700); // Gold particles
                        hotdogData.velocity.add(controls.getDirection(new THREE.Vector3()).multiplyScalar(12));
                        hotdogData.velocity.y = 6;
                        hotdogData.scared = true;
                        
                        if (hotdogData.health <= 0) {
                            mobGroup.remove(hitWrapper);
                            hotdogs = hotdogs.filter(h => h !== hotdogData);
                            healPlayer(25); // REWARD
                        }
                        return;
                    }
                }
            }

            const objects = [...blockGroup.children, ...transparentBlockGroup.children];
            const intersections = raycaster.intersectObjects(objects);

            if (intersections.length > 0) {
                const intersect = intersections[0];
                if (intersect.distance > 6) return;

                const bx = intersect.object.position.x;
                const by = intersect.object.position.y;
                const bz = intersect.object.position.z;

                if (button === 0) { // Mine
                    createParticles(intersect.object.position, intersect.object.material.color || intersect.object.material[2].color || 0x888888);

                    const clickedMesh = intersect.object;
                    if (clickedMesh.parent) {
                        clickedMesh.parent.remove(clickedMesh);
                    }

                    const entry = getBlockData(bx, by, bz);
                    if (entry) {
                        // NEW: Remove from active lights if mining glowstone
                        if (entry.type === 'glowstone') {
                            activeLights.delete(getBlockKey(bx, by, bz));
                        }
                        
                        if (entry.mesh && entry.mesh !== clickedMesh && entry.mesh.parent) {
                             entry.mesh.parent.remove(entry.mesh);
                        }
                        worldData.delete(getBlockKey(bx, by, bz)); 
                        recordModification(bx, by, bz, 'air'); 
                    }
                    
                    revealNeighbors(bx, by, bz);

                } else if (button === 2) { // Build
                    const hitBlockPos = intersect.object.position.clone();
                    const newPos = hitBlockPos.add(intersect.face.normal);
                    
                    const pPos = controls.getObject().position;
                    if (Math.abs(newPos.x - pPos.x) < 0.6 && Math.abs(newPos.z - pPos.z) < 0.6 && Math.abs(newPos.y - (pPos.y - PLAYER_HEIGHT/2)) < 1.5) {
                        return;
                    }

                    const x = Math.round(newPos.x);
                    const y = Math.round(newPos.y);
                    const z = Math.round(newPos.z);
                    
                    if (!hasBlockData(x, y, z)) {
                        createBlock(x, y, z, blockTypes[currentBlockIndex], true);
                        recordModification(x, y, z, blockTypes[currentBlockIndex]); 
                    }
                }
            }
        }
        
        function updateContinuousActions(delta) {
            if (actionCooldown > 0) actionCooldown -= delta;

            if (isLeftMouseDown && actionCooldown <= 0) {
                performAction(0);
                actionCooldown = ACTION_DELAY;
            }
            if (isRightMouseDown && actionCooldown <= 0) {
                performAction(2);
                actionCooldown = ACTION_DELAY;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            document.getElementById('fps').innerText = Math.round(1/delta);

            if (controls.enabled) {
                updateChunks(); 
                updateContinuousActions(delta); 
                skyMesh.position.copy(controls.getObject().position);
                animatePickaxe(delta);
                updateParticles(delta);
                
                updateMobs(delta);
                
                // Dynamic Lighting Update
                const playerY = controls.getObject().position.y;
                
                let depthFactor = 0;
                if (playerY < 4) {
                    depthFactor = (playerY - 4) / -16; 
                    depthFactor = Math.max(0, Math.min(1, depthFactor)); 
                }

                const brightness = 1.0 - (depthFactor * 0.96);

                ambientLight.intensity = 0.8 * brightness;
                dirLight.intensity = 0.6 * brightness;

                const baseColor = new THREE.Color(0x87CEEB);
                const blackColor = new THREE.Color(0x000000);
                const currentColor = baseColor.clone().lerp(blackColor, depthFactor); 
                
                scene.fog.color.copy(currentColor).multiplyScalar(brightness);
                scene.background.copy(currentColor).multiplyScalar(brightness);

                if (playerY < -5) {
                    skyMesh.visible = false;
                } else {
                    skyMesh.visible = true;
                    const baseTop = new THREE.Color(0x95D8EE);
                    const baseBottom = new THREE.Color(0x87CEEB);
                    skyMesh.material.uniforms.topColor.value.copy(baseTop).multiplyScalar(brightness);
                    skyMesh.material.uniforms.bottomColor.value.copy(baseBottom).multiplyScalar(brightness);
                }
                
                scene.children.forEach(obj => {
                    if (obj.material && obj.material.map && obj.material.map.wrapS === THREE.RepeatWrapping) {
                        obj.material.map.offset.x += CLOUD_SPEED * delta;
                    }
                });

                velocity.x -= velocity.x * FRICTION * delta;
                velocity.z -= velocity.z * FRICTION * delta;

                if (!isFlying) {
                    velocity.y -= GRAVITY * delta;
                } else {
                    velocity.y -= velocity.y * FRICTION * delta;
                    if (moveUp) velocity.y += FLY_ASCEND_SPEED * ACCELERATION * delta;
                    if (moveDown) velocity.y -= FLY_ASCEND_SPEED * ACCELERATION * delta;
                }

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const speed = isFlying ? FLY_SPEED : PLAYER_SPEED;
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * ACCELERATION * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * ACCELERATION * delta;

                const playerObj = controls.getObject();
                const originalPos = playerObj.position.clone();
                
                // 1. Try Moving X
                playerObj.translateX(-velocity.x * delta);
                if (checkPlayerCollision(playerObj.position.x, playerObj.position.y, playerObj.position.z)) {
                    if (!checkPlayerCollision(playerObj.position.x, playerObj.position.y + 1, playerObj.position.z)) {
                         playerObj.position.y += 1.0;
                    } else {
                        playerObj.position.x = originalPos.x;
                        playerObj.position.z = originalPos.z;
                        velocity.x = 0;
                    }
                }

                // 2. Try Moving Z
                const posAfterX = playerObj.position.clone();
                playerObj.translateZ(velocity.z * delta);
                if (checkPlayerCollision(playerObj.position.x, playerObj.position.y, playerObj.position.z)) {
                    if (!checkPlayerCollision(playerObj.position.x, playerObj.position.y + 1, playerObj.position.z)) {
                        playerObj.position.y += 1.0;
                    } else {
                        playerObj.position.x = posAfterX.x;
                        playerObj.position.z = posAfterX.z;
                        velocity.z = 0;
                    }
                }

                // 3. Try Moving Y
                playerObj.position.y += (velocity.y * delta);
                if (checkPlayerCollision(playerObj.position.x, playerObj.position.y, playerObj.position.z)) {
                    if (velocity.y < 0) {
                        canJump = true;
                        velocity.y = 0;
                        playerObj.position.y = Math.ceil(playerObj.position.y - PLAYER_HEIGHT) + PLAYER_HEIGHT;
                    } else if (velocity.y > 0) {
                        velocity.y = 0;
                        playerObj.position.y = Math.floor(playerObj.position.y);
                    }
                }

                if (playerObj.position.y < -100 && !isFlying) {
                    velocity.y = 0;
                    playerObj.position.y = 50;
                    playerHealth -= 20;
                    updateHealthUI();
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();

    </script>
</body>
</html>
